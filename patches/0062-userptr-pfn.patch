From 2a09b378aeb637728e9844a2244a60dd6f202e39 Mon Sep 17 00:00:00 2001
From: Chris Wilson <chris@chris-wilson.co.uk>
Date: Tue, 27 Oct 2020 22:29:10 -0700
Subject: [PATCH] userptr-pfn

This works for a simple vmap (single indirection), untested with a
double indirection like virtio.

Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
---
 drivers/gpu/drm/i915/gem/i915_gem_mman.c    |  4 +
 drivers/gpu/drm/i915/gem/i915_gem_mman.h    |  3 +
 drivers/gpu/drm/i915/gem/i915_gem_userptr.c | 85 +++++++++++++++++++++
 3 files changed, 92 insertions(+)

diff --git a/drivers/gpu/drm/i915/gem/i915_gem_mman.c b/drivers/gpu/drm/i915/gem/i915_gem_mman.c
index 2b5533048499..f95ae7a48ad8 100644
--- a/drivers/gpu/drm/i915/gem/i915_gem_mman.c
+++ b/drivers/gpu/drm/i915/gem/i915_gem_mman.c
@@ -920,6 +920,10 @@ int i915_gem_mmap(struct file *filp, struct vm_area_struct *vma)
 	return err;
 }
 
+bool is_i915_gem_vma(const struct vm_area_struct *vma) {
+	return vma->vm_ops == &vm_ops_gtt || vma->vm_ops == &vm_ops_cpu;
+}
+
 #if IS_ENABLED(CONFIG_DRM_I915_SELFTEST)
 #include "selftests/i915_gem_mman.c"
 #endif
diff --git a/drivers/gpu/drm/i915/gem/i915_gem_mman.h b/drivers/gpu/drm/i915/gem/i915_gem_mman.h
index f0e34a30861f..94835986d847 100644
--- a/drivers/gpu/drm/i915/gem/i915_gem_mman.h
+++ b/drivers/gpu/drm/i915/gem/i915_gem_mman.h
@@ -40,4 +40,7 @@ i915_gem_mmap_offset_attach(struct drm_i915_gem_object *obj,
 int i915_gem_update_vma_info(struct drm_i915_gem_object *obj,
 			     struct i915_mmap_offset *mmo,
 			     struct vm_area_struct *vma);
+
+bool is_i915_gem_vma(const struct vm_area_struct *vma);
+
 #endif
diff --git a/drivers/gpu/drm/i915/gem/i915_gem_userptr.c b/drivers/gpu/drm/i915/gem/i915_gem_userptr.c
index e946032b13e4..c43661b0da07 100644
--- a/drivers/gpu/drm/i915/gem/i915_gem_userptr.c
+++ b/drivers/gpu/drm/i915/gem/i915_gem_userptr.c
@@ -12,6 +12,7 @@
 
 #include "i915_drv.h"
 #include "i915_gem_ioctls.h"
+#include "i915_gem_mman.h"
 #include "i915_gem_object.h"
 #include "i915_scatterlist.h"
 
@@ -439,6 +440,82 @@ __i915_gem_userptr_alloc_pages(struct drm_i915_gem_object *obj,
 	return st;
 }
 
+static bool
+__vma_pfn_set_pages(struct drm_i915_gem_object *obj,
+		    struct vm_area_struct *vma,
+		    struct get_pages_work *work)
+{
+	unsigned long addr, pfn, end;
+	struct scatterlist *sg;
+	struct sg_table *st;
+
+	/* For fear of mmu-invalidate recursion, don't map our own buffers */
+	if (is_i915_gem_vma(vma))
+		return false;
+
+	st = kmalloc(sizeof(*st), GFP_KERNEL);
+	if (!st)
+		return false;
+
+	if (sg_alloc_table(st, obj->base.size >> PAGE_SHIFT, GFP_KERNEL))
+		goto err_st;
+
+	sg = st->sgl;
+	addr = obj->userptr.ptr;
+	end = addr + obj->base.size;
+	while (addr < end) {
+		if (follow_pfn(vma, addr, &pfn))
+			goto err_sg;
+
+		sg->offset = 0;
+		sg->length = PAGE_SIZE;
+
+		sg_dma_address(sg) = PFN_PHYS(pfn);
+		sg_dma_len(sg) = PAGE_SIZE;
+
+		sg = sg_next(sg);
+		addr += PAGE_SIZE;
+	}
+
+	mutex_lock_nested(&obj->mm.lock, I915_MM_GET_PAGES);
+	if (obj->userptr.work == &work->work) {
+		__i915_gem_object_set_pages(obj, st, PAGE_SIZE);
+		obj->userptr.work = NULL;
+	}
+	mutex_unlock(&obj->mm.lock);
+	return true;
+
+err_sg:
+	sg_free_table(st);
+err_st:
+	kfree(st);
+	return false;
+}
+
+static bool
+maybe_set_pages_from_pfn(struct drm_i915_gem_object *obj,
+			 struct get_pages_work *work)
+{
+	struct mm_struct *mm = obj->userptr.mm->mm;
+	struct vm_area_struct *vma;
+	bool result = false;
+	printk("xiaolin@%s\n", __func__);
+	if (!mmget_not_zero(mm))
+		return false;
+
+	mmap_read_lock(mm);
+	vma = find_vma(mm, obj->userptr.ptr);
+	if (vma) {
+		if (vma->vm_start <= obj->userptr.ptr &&
+		    vma->vm_end >= obj->userptr.ptr + obj->base.size)
+			result = __vma_pfn_set_pages(obj, vma, work);
+	}
+	mmap_read_unlock(mm);
+	mmput(mm);
+
+	return result;
+}
+
 static void
 __i915_gem_userptr_get_pages_worker(struct work_struct *_work)
 {
@@ -448,6 +525,10 @@ __i915_gem_userptr_get_pages_worker(struct work_struct *_work)
 	unsigned long pinned;
 	struct page **pvec;
 	int ret;
+	
+	if (maybe_set_pages_from_pfn(obj, work))
+		goto out;
+
 
 	ret = -ENOMEM;
 	pinned = 0;
@@ -510,6 +591,10 @@ __i915_gem_userptr_get_pages_worker(struct work_struct *_work)
 	i915_gem_object_put(obj);
 	put_task_struct(work->task);
 	kfree(work);
+out:
+ 	i915_gem_object_put(obj);
+ 	put_task_struct(work->task);
+ 	kfree(work);
 }
 
 static struct sg_table *
-- 
2.25.1

